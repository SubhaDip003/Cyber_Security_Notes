# 1.1 Hypertext Transfer Protocol (HTTP)

HTTP is the application level protocol that allows web and mobile applications to communicate over the internet. It works using a clientâ€“server model, where the client requests a resource and the server responds with the requested data. The term _hypertext_ refers to text that contains links to other resources and is easy for users to navigate.

Most web communication happens through HTTP requests and responses, usually over port 80 by default. When we enter a `Fully Qualified Domain Name` (`FQDN`) as a `Uniform Resource Locator` (`URL`) like [_www.hackthebox.com_](http://www.hackthebox.com/), our browser sends an HTTP request to the server, and the server processes it and sends back the website content.

### URL

Resources over HTTP are accessed via a `URL`, which offers many more specifications than simply specifying a website we want to visit. Let's look at the structure of a URL:

<figure><img src="../.gitbook/assets/image (77).png" alt=""><figcaption></figcaption></figure>

Here is what each component stands for:

| Component    | Example                                                       | Description                                                                                                                                                                           |
| ------------ | ------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Scheme       | `http://`, `https://`, `ftp://`, `mailto://`, `file://`, etc. | This is used to identify the protocol being accessed by the client, and ends with a colon and a double slash (`://`)                                                                  |
| User Info    | `admin:password@`                                             | This is an optional component that contains the credentials (separated by a colon `:`) used to authenticate to the host, and is separated from the host with an at sign (`@`)         |
| Host         | `inlanefreight.com`                                           | The host signifies the resource location. This can be a hostname or an IP address                                                                                                     |
| Port         | `:80`                                                         | The `Port` is separated from the `Host` by a colon (`:`). If no port is specified, `http` schemes default to port `80` and `https` default to port `443`                              |
| Path         | `/dashboard.php`                                              | This points to the resource being accessed, which can be a file or a folder. If there is no path specified, the server returns the default index (e.g. `index.html`).                 |
| Query String | `?login=true`                                                 | The query string starts with a question mark (`?`), and consists of a parameter (e.g. `login`) and a value (e.g. `true`). Multiple parameters can be separated by an ampersand (`&`). |
| Fragment     | `#status`                                                     | Fragments are processed by the browsers on the client-side to locate sections within the primary resource (e.g. a header or section on the page).                                     |

Not all components are required to access a resource. The main mandatory fields are the **scheme** and the **host**, without which the request would have no resource to request.

### HTTP Flow

<figure><img src="../.gitbook/assets/image (79).png" alt=""><figcaption></figcaption></figure>

1. First, the user types **inlanefreight.com** into the browser and presses Enter. The browser does not know the IP address of this domain yet.
2. Next, the browser asks a **DNS server** to translate the domain name into an IP address. Before asking external DNS servers, the browser usually checks the local `/etc/hosts` file. If the domain is not found there, the request goes to a DNS server on the internet.
3. Then, the DNS server looks up the domain **inlanefreight.com** and sends back its IP address to the browser. This step is necessary because servers communicate using IP addresses, not domain names.
4. After receiving the IP address, the browser sends an **HTTP GET request** to that IP on the default HTTP port **80**, requesting the root path `/`. The web server receives this request, processes it, and looks for the default file configured for the root path. In most cases, this is **index.html**.
5. Finally, the server sends an **HTTP response** back to the browser containing the contents of `index.html` along with a status code like **200 OK**, which means the request was successful. The browser then renders the page and shows the website to the user.

### cURL

[cURL](https://curl.haxx.se/) (client URL) is a command-line tool and library that primarily supports HTTP along with many other protocols. This makes it a good candidate for scripts as well as automation, making it essential for sending various types of web requests from the command line, which is necessary for many types of web penetration tests.

We can send a basic HTTP request to any URL by using it as an argument for cURL, as follows:

```bash
SubhaDip03@htb[/htb]$ curl inlanefreight.com

<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<html><head>
...SNIP...
```

We see that cURL does not render the HTML/JavaScript/CSS code, unlike a web browser, but prints it in its raw format. However, as penetration testers, we are mainly interested in the request and response context, which usually becomes much faster and more convenient than a web browser.

We may also use cURL to download a page or a file and output the content into a file using the `-O` flag. If we want to specify the output file name, we can use the `-o` flag and specify the name. Otherwise, we can use `-O` and cURL will use the remote file name, as follows:

```bash
SubhaDip03@htb[/htb]$ curl -O inlanefreight.com/index.html
SubhaDip03@htb[/htb]$ ls
index.html
```

As we can see, the output was not printed this time but rather saved into `index.html`. We noticed that cURL still printed some status while processing the request. We can silent the status with the `-s` flag, as follows:

```bash
SubhaDip03@htb[/htb]$ curl -s -O inlanefreight.com/index.html
```

This time, cURL did not print anything, as the output was saved into the `index.html` file. Finally, we may use the `-h` flag to see what other options we may use with cURL:

```bash
SubhaDip03@htb[/htb]$ curl -h
Usage: curl [options...] <url>
 -d, --data <data>   HTTP POST data
 -h, --help <category> Get help for commands
 -i, --include       Include protocol response headers in the output
 -o, --output <file> Write to file instead of stdout
 -O, --remote-name   Write output to a file named as the remote file
 -s, --silent        Silent mode
 -u, --user <user:password> Server user and password
 -A, --user-agent <name> Send User-Agent <name> to server
 -v, --verbose       Make the operation more talkative

This is not the full help, this menu is stripped into categories.
Use "--help category" to get an overview of all categories.
Use the user manual `man curl` or the "--help all" flag for all options.
```

As the above message mentions, we may use `--help all` to print a more detailed help menu, or `--help category` (e.g. `-h http`) to print the detailed help of a specific flag. If we ever need to read more detailed documentation, we can use `man curl` to view the full cURL manual page.
